design_architecture:
  description: >
    Design the comprehensive technical architecture for Milestone {current_milestone} by:
    1. Reading the approved Product Roadmap (from Product Manager)
    2. Understanding the skeleton plugin structure (from {skeleton_plugin_path})
    3. Creating a detailed technical specification that bridges business requirements with implementation
    
    **YOUR MISSION:** Create a complete architectural blueprint that allows Backend and Frontend
    developers to work independently while building a cohesive system. This specification is the
    "contract" between PM's vision and developers' implementation.
    
    **STEP 1: Review Product Roadmap & Requirements**
    
    Read the approved milestone file: `outputs/analysis/milestones/milestone-{current_milestone}.md`
    
    Extract:
    - Feature list and descriptions
    - Acceptance criteria
    - User stories
    - Technical requirements mentioned by PM
    - Success metrics
    
    **STEP 2: Understand Skeleton Plugin Structure**
    
    A. Look for architecture documentation:
       - {skeleton_plugin_path}/ARCHITECTURE.md
       - {skeleton_plugin_path}/README.md
       - {skeleton_plugin_path}/docs/
    
    B. If no docs, analyze the code:
       - Folder structure (includes/, src/, admin-react/)
       - Existing PHP classes and patterns
       - React component organization
       - Naming conventions (namespaces, prefixes)
       - Current patterns (DI, hooks, state management)
    
    **STEP 3: Design the Complete Architecture**
    
    Create a detailed technical specification that includes:
    
    ### A. System Architecture Overview
    - High-level component diagram
    - Data flow: User → Frontend → REST API → Backend → Database
    - Module responsibilities and boundaries
    - Integration points between components
    
    ### B. Backend Architecture (PHP)
    
    **For EACH feature in the milestone, specify:**
    
    1. **PHP Class Structure**
       - Exact file path: `src/admin/class-{feature-name}.php`
       - Class name, namespace, extends/implements
       - Public methods with signatures: `public function methodName($param1, $param2): ReturnType`
       - Dependencies (what other classes it needs)
       - SOLID principle application
    
    2. **WordPress Integration**
       - Hooks to register: `add_action('hook_name', [$this, 'method'], priority)`
       - Filters to implement: `add_filter('filter_name', [$this, 'method'])`
       - Custom post types: `register_post_type('cpt_name', $args)`
       - Taxonomies: `register_taxonomy('tax_name', $post_type, $args)`
    
    3. **Database Schema** (if needed)
       - Table name: `{wpdb->prefix}plugin_table_name`
       - Columns with types: `id INT(11) AUTO_INCREMENT, name VARCHAR(255), ...`
       - Indexes and foreign keys
       - Migration strategy
    
    4. **REST API Endpoints**
       - Route: `/wp-json/plugin-namespace/v1/resource`
       - Method: GET, POST, PUT, DELETE
       - Request parameters: `{ param: type, ... }`
       - Response structure: `{ success: bool, data: {...}, error: string }`
       - Permission callback: `current_user_can('capability')`
       - Nonce validation requirements
    
    ### C. Frontend Architecture (React)
    
    **For EACH feature, specify:**
    
    1. **Component Structure**
       - Page component: `admin-react/src/pages/FeatureName.jsx`
       - Child components: `admin-react/src/components/FeatureComponent.jsx`
       - Component props interface: `{ propName: PropType, ... }`
       - State needed: `useState<Type>(initialValue)`
    
    2. **API Integration**
       - Custom hook: `admin-react/src/hooks/useFeatureData.js`
       - API calls: `fetch('/wp-json/plugin/v1/endpoint', { method, body })`
       - Error handling: try/catch with user feedback
       - Loading states: `isLoading`, `isError`, `isSuccess`
    
    3. **Material-UI Components**
       - Which MUI components to use: `Button, TextField, Dialog, DataGrid, etc.`
       - Layout structure: `<Container><Grid><Paper>...`
       - Form handling: `useForm()` or controlled components
       - Validation: client-side validation rules
    
    4. **Routing**
       - Route path: `/admin.php?page=plugin-page#/feature`
       - Navigation: `<Link to="/feature">Feature</Link>`
       - Route guards: permission checks
    
    ### D. Data Flow & Contracts
    
    **Define the "contract" between BE and FE:**
    
    1. **API Data Structures**
       ```typescript
       // What Backend sends
       interface FeatureResponse {
         id: number;
         name: string;
         status: 'active' | 'inactive';
         createdAt: string;  // ISO format
       }
       
       // What Frontend sends
       interface FeatureRequest {
         name: string;
         config: { key: value };
       }
       ```
    
    2. **Error Response Format**
       ```json
       {
         "success": false,
         "error": {
           "code": "validation_error",
           "message": "Name is required",
           "field": "name"
         }
       }
       ```
    
    3. **State Management**
       - Where data lives (Context, local state, URL params)
       - When to refetch data
       - Cache invalidation strategy
    
    ### E. File Structure Changes
    
    **Backend Files to Create:**
    ```
    includes/
      class-{feature}-manager.php        # Main feature class
    src/
      admin/
        class-{feature}-admin.php         # Admin functionality
        class-{feature}-ajax.php          # AJAX handlers
      api/
        class-{feature}-controller.php    # REST API controller
      models/
        class-{feature}.php               # Data model
    ```
    
    **Frontend Files to Create:**
    ```
    admin-react/src/
      pages/
        {Feature}Page.jsx                 # Main page component
      components/
        {Feature}List.jsx                 # List component
        {Feature}Form.jsx                 # Form component
        {Feature}Details.jsx              # Details component
      hooks/
        use{Feature}Data.js               # Data fetching hook
        use{Feature}Form.js               # Form logic hook
      utils/
        {feature}Api.js                   # API client
    ```
    
    ### F. Testing Requirements
    
    **Backend Tests:**
    - `tests/php/test-class-{feature}.php` - Unit tests for each class
    - Test scenarios: CRUD operations, validation, permissions
    - Mock WordPress functions with Brain Monkey
    
    **Frontend Tests:**
    - `{Component}.test.jsx` co-located with components
    - Test rendering, user interactions, API integration
    - Mock API calls with MSW or jest.mock
    
    **E2E Tests:**
    - `tests/e2e/{feature}.spec.js` - User workflow tests
    - Test happy path and error scenarios
    
    ### G. Security Considerations
    
    **Backend:**
    - Nonce validation: `wp_verify_nonce($nonce, 'action_name')`
    - Capability checks: `current_user_can('edit_posts')`
    - Input sanitization: `sanitize_text_field()`, `wp_kses()`
    - Output escaping: `esc_html()`, `esc_attr()`, `esc_url()`
    - SQL injection prevention: Use `$wpdb->prepare()`
    
    **Frontend:**
    - XSS prevention: Never use `dangerouslySetInnerHTML`
    - Validate user input before submission
    - Display validation errors clearly
    - Sanitize data from API before rendering
    
    ### H. Developer Handoff Checklist
    
    **Backend Developer needs:**
    ✅ Exact class names and file paths
    ✅ Method signatures with parameters and return types
    ✅ WordPress hooks/filters to register
    ✅ Database schema (if needed)
    ✅ REST API endpoint specifications
    ✅ Data validation rules
    ✅ Permission requirements
    
    **Frontend Developer needs:**
    ✅ Component names and file paths
    ✅ Props interfaces for each component
    ✅ API endpoints to call (URLs, methods, payloads)
    ✅ Expected response structures
    ✅ MUI components to use
    ✅ Routing configuration
    ✅ Error handling patterns
    
    **Both developers need:**
    ✅ Data structure contracts (TypeScript interfaces)
    ✅ API request/response formats
    ✅ Error handling patterns
    ✅ Testing requirements

  expected_output: >
    Comprehensive Technical Specification saved to outputs/architecture/milestone-{current_milestone}-architecture.md:
    
    # Technical Architecture Specification
    ## Milestone: {current_milestone}
    
    ## 1. Executive Summary
    - Features being implemented in this milestone
    - Key architectural decisions
    - Technology stack
    - Integration approach
    
    ## 2. Product Requirements (from PM)
    - Feature list from approved roadmap
    - User stories and acceptance criteria
    - Success metrics
    - Business rules
    
    ## 3. Skeleton Plugin Analysis
    - Current architecture patterns identified
    - Folder structure being followed
    - Naming conventions to use
    - Existing patterns to respect (DI, hooks, state management)
    
    ## 4. System Architecture Overview
    - High-level component diagram (ASCII or description)
    - Data flow: User → React → REST API → PHP → Database
    - Module responsibilities
    - Integration points
    
    ## 5. Backend Architecture Specification
    
    ### For EACH feature:
    
    #### 5.1 PHP Class Structure
    ```
    File: src/admin/class-{feature-name}.php
    Namespace: PluginName\Admin
    Class: Feature_Name
    Extends: Base_Class (if any)
    Implements: Interface_Name (if any)
    
    Dependencies:
    - Feature_Repository
    - Settings_Manager
    
    Public Methods:
    - __construct(Feature_Repository $repo, Settings_Manager $settings)
    - register_hooks(): void
    - handle_action($data): bool|WP_Error
    - validate_input($data): array
    - get_feature_data($id): array|WP_Error
    
    SOLID Application:
    - Single Responsibility: Only handles feature admin logic
    - Open/Closed: Extends base, uses interfaces
    - Dependency Injection: Constructor injection
    ```
    
    #### 5.2 WordPress Integration
    ```
    Hooks to Register:
    - add_action('admin_init', [$this, 'register_settings'], 10)
    - add_action('admin_menu', [$this, 'add_menu_page'], 20)
    - add_action('wp_ajax_feature_action', [$this, 'handle_ajax'])
    
    Filters:
    - add_filter('plugin_feature_data', [$this, 'filter_data'], 10, 2)
    
    Custom Post Types:
    - register_post_type('plugin_feature', [
        'labels' => [...],
        'public' => false,
        'show_ui' => true,
        'supports' => ['title', 'editor']
      ])
    ```
    
    #### 5.3 Database Schema (if needed)
    ```sql
    CREATE TABLE {wpdb->prefix}plugin_features (
      id BIGINT(20) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
      name VARCHAR(255) NOT NULL,
      config TEXT,
      status ENUM('active', 'inactive') DEFAULT 'active',
      user_id BIGINT(20) UNSIGNED NOT NULL,
      created_at DATETIME NOT NULL,
      updated_at DATETIME NOT NULL,
      INDEX idx_status (status),
      INDEX idx_user (user_id),
      FOREIGN KEY (user_id) REFERENCES {wpdb->prefix}users(ID)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
    ```
    
    #### 5.4 REST API Endpoints
    ```
    Endpoint 1: Get All Features
    - Route: /wp-json/plugin-namespace/v1/features
    - Method: GET
    - Parameters: 
      * page (int, optional, default=1)
      * per_page (int, optional, default=10)
      * status (string, optional, 'active'|'inactive')
    - Response: {
        success: true,
        data: [
          { id: 1, name: "Feature", status: "active", ... }
        ],
        pagination: {
          total: 100,
          pages: 10,
          current: 1
        }
      }
    - Permission: current_user_can('manage_options')
    - Nonce: Required in X-WP-Nonce header
    
    Endpoint 2: Create Feature
    - Route: /wp-json/plugin-namespace/v1/features
    - Method: POST
    - Request Body: {
        name: string (required, max 255 chars),
        config: object (optional),
        status: 'active'|'inactive' (optional, default='active')
      }
    - Validation:
      * name: required, string, max_length(255)
      * config: optional, object
      * status: optional, in_array(['active', 'inactive'])
    - Response Success: {
        success: true,
        data: { id: 1, name: "...", ... },
        message: "Feature created successfully"
      }
    - Response Error: {
        success: false,
        error: {
          code: "validation_error",
          message: "Name is required",
          field: "name"
        }
      }
    - Permission: current_user_can('manage_options')
    - Nonce: Required
    
    [... similar specs for UPDATE, DELETE endpoints ...]
    ```
    
    ## 6. Frontend Architecture Specification
    
    ### For EACH feature:
    
    #### 6.1 Component Structure
    ```
    Page Component:
    File: admin-react/src/pages/FeaturePage.jsx
    Purpose: Main page container for feature management
    Props: None (gets data from URL params)
    State:
      - features: Array<Feature>
      - isLoading: boolean
      - error: string | null
      - selectedFeature: Feature | null
    Children:
      - <FeatureList />
      - <FeatureForm />
      - <FeatureDetails />
    
    Child Component 1: FeatureList
    File: admin-react/src/components/FeatureList.jsx
    Purpose: Display paginated list of features
    Props: {
      features: Array<{ id, name, status, createdAt }>,
      onSelect: (id) => void,
      onDelete: (id) => void,
      isLoading: boolean
    }
    MUI Components:
      - <DataGrid /> for table
      - <IconButton /> for actions
      - <Chip /> for status
    
    Child Component 2: FeatureForm
    File: admin-react/src/components/FeatureForm.jsx
    Purpose: Create/edit feature form
    Props: {
      feature: Feature | null,  // null = create, object = edit
      onSubmit: (data) => Promise<void>,
      onCancel: () => void
    }
    MUI Components:
      - <Dialog />
      - <TextField />
      - <Select />
      - <Button />
    Validation:
      - name: required, maxLength 255
      - status: required, oneOf ['active', 'inactive']
    ```
    
    #### 6.2 API Integration
    ```
    Custom Hook: useFeatureData
    File: admin-react/src/hooks/useFeatureData.js
    
    export function useFeatureData() {
      const [features, setFeatures] = useState([]);
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState(null);
      
      const fetchFeatures = async (page = 1) => {
        setIsLoading(true);
        try {
          const response = await fetch(
            `/wp-json/plugin/v1/features?page=${page}`,
            {
              headers: {
                'X-WP-Nonce': wpApiSettings.nonce
              }
            }
          );
          const data = await response.json();
          if (data.success) {
            setFeatures(data.data);
          } else {
            setError(data.error.message);
          }
        } catch (err) {
          setError(err.message);
        } finally {
          setIsLoading(false);
        }
      };
      
      const createFeature = async (featureData) => {
        // ... similar pattern
      };
      
      return { features, isLoading, error, fetchFeatures, createFeature };
    }
    ```
    
    #### 6.3 Routing Configuration
    ```
    Route: /admin.php?page=plugin-features#/features
    Component: <FeaturePage />
    
    Nested Routes:
    - /features -> List view
    - /features/new -> Create form
    - /features/:id -> Detail view
    - /features/:id/edit -> Edit form
    
    Navigation:
    - <Link to="/features">All Features</Link>
    - <Link to="/features/new">Add New</Link>
    ```
    
    ## 7. Data Contracts (TypeScript Interfaces)
    
    ```typescript
    // Backend sends this
    interface Feature {
      id: number;
      name: string;
      config: Record<string, any>;
      status: 'active' | 'inactive';
      userId: number;
      createdAt: string;  // ISO 8601
      updatedAt: string;  // ISO 8601
    }
    
    // Frontend sends this to create
    interface CreateFeatureRequest {
      name: string;
      config?: Record<string, any>;
      status?: 'active' | 'inactive';
    }
    
    // Frontend sends this to update
    interface UpdateFeatureRequest {
      name?: string;
      config?: Record<string, any>;
      status?: 'active' | 'inactive';
    }
    
    // API Response wrapper
    interface ApiResponse<T> {
      success: boolean;
      data?: T;
      error?: {
        code: string;
        message: string;
        field?: string;
      };
      pagination?: {
        total: number;
        pages: number;
        current: number;
        perPage: number;
      };
    }
    ```
    
    ## 8. File Structure Changes
    
    ### Backend Files to Create:
    ```
    includes/
      class-feature-loader.php          # Autoloader/bootstrapper
    
    src/
      admin/
        class-feature-admin.php          # Admin UI registration
        class-feature-settings.php       # Settings page
      
      api/
        class-feature-controller.php     # REST API endpoints
        class-api-response.php           # Response formatter
      
      models/
        class-feature.php                # Feature data model
        class-feature-repository.php     # Data access layer
      
      validators/
        class-feature-validator.php      # Input validation
    ```
    
    ### Frontend Files to Create:
    ```
    admin-react/src/
      pages/
        FeaturePage.jsx                  # Main page
        
      components/
        features/
          FeatureList.jsx                # List component
          FeatureForm.jsx                # Form component
          FeatureDetails.jsx             # Details view
          FeatureListItem.jsx            # List item component
          
      hooks/
        useFeatureData.js                # Data fetching
        useFeatureForm.js                # Form logic
        
      utils/
        featureApi.js                    # API client
        featureValidation.js             # Client-side validation
        
      types/
        feature.d.ts                     # TypeScript definitions
    ```
    
    ## 9. Testing Requirements
    
    ### Backend Tests:
    ```
    tests/php/
      test-class-feature.php             # Unit tests for Feature class
      test-class-feature-repository.php  # Repository tests
      test-class-feature-controller.php  # API endpoint tests
      test-class-feature-validator.php   # Validation tests
    
    Test Coverage:
    - CRUD operations
    - Input validation (valid/invalid cases)
    - Permission checks
    - Error handling
    - Database queries
    ```
    
    ### Frontend Tests:
    ```
    admin-react/src/
      components/features/
        FeatureList.test.jsx             # Component tests
        FeatureForm.test.jsx             # Form tests
      hooks/
        useFeatureData.test.js           # Hook tests
    
    Test Coverage:
    - Component rendering
    - User interactions (clicks, form input)
    - API integration (mocked)
    - Error states
    - Loading states
    ```
    
    ### E2E Tests:
    ```
    tests/e2e/
      feature-crud.spec.js               # Full CRUD workflow
      feature-validation.spec.js         # Validation scenarios
      feature-permissions.spec.js        # Permission tests
    
    Test Scenarios:
    - Create new feature (happy path)
    - Edit existing feature
    - Delete feature with confirmation
    - Validation errors display correctly
    - Unauthorized user cannot access
    ```
    
    ## 10. Security Implementation
    
    ### Backend Security:
    ```php
    // Nonce validation
    if (!wp_verify_nonce($_REQUEST['_wpnonce'], 'feature_action')) {
      wp_die('Security check failed');
    }
    
    // Capability check
    if (!current_user_can('manage_options')) {
      return new WP_Error('forbidden', 'Insufficient permissions');
    }
    
    // Input sanitization
    $name = sanitize_text_field($_POST['name']);
    $config = wp_kses_post($_POST['config']);
    
    // Output escaping
    echo '<h1>' . esc_html($feature->name) . '</h1>';
    
    // SQL injection prevention
    $wpdb->prepare("SELECT * FROM {$wpdb->prefix}features WHERE id = %d", $id);
    ```
    
    ### Frontend Security:
    ```javascript
    // XSS prevention - never use dangerouslySetInnerHTML
    <div>{feature.name}</div>  // React escapes by default
    
    // Validate before submit
    if (!name.trim()) {
      setError('Name is required');
      return;
    }
    
    // Sanitize API data
    const sanitizedData = {
      ...data,
      name: DOMPurify.sanitize(data.name)
    };
    ```
    
    ## 11. Developer Handoff
    
    ### Backend Developer Checklist:
    ✅ Read sections 5 (Backend Architecture) and 7 (Data Contracts)
    ✅ Create all PHP classes listed in section 8
    ✅ Implement all REST API endpoints with exact specifications
    ✅ Follow security guidelines in section 10
    ✅ Write PHPUnit tests per section 9
    ✅ Use skeleton's naming conventions and patterns
    ✅ Commit to feature branch: `feature/milestone-{n}-backend`
    
    ### Frontend Developer Checklist:
    ✅ Read sections 6 (Frontend Architecture) and 7 (Data Contracts)
    ✅ Create all React components listed in section 8
    ✅ Use exact API endpoints and request/response formats from section 5.4
    ✅ Implement Material-UI components as specified
    ✅ Follow security guidelines in section 10
    ✅ Write Jest tests per section 9
    ✅ Commit to feature branch: `feature/milestone-{n}-frontend`
    
    ### Integration Points:
    - Backend provides: REST API endpoints at exact URLs with exact response formats
    - Frontend consumes: API using fetch with nonce headers
    - Contract: TypeScript interfaces in section 7 must match exactly
    - Error handling: Both sides use same error response structure
    
    ## 12. Implementation Timeline
    
    Week 1:
    - Backend: Database schema, models, repositories
    - Frontend: Component structure, basic UI
    
    Week 2:
    - Backend: REST API endpoints, validation
    - Frontend: API integration, hooks
    
    Week 3:
    - Backend: Security, error handling, tests
    - Frontend: Form validation, error handling, tests
    
    Week 4:
    - Integration testing
    - E2E tests
    - Code review
    - QA validation

  agent: software_architect
  output_file: 'outputs/architecture/milestone-{current_milestone}-architecture.md'

implement_backend:
  description: >
    Implement the WordPress backend features for Milestone {current_milestone}
    based on the architecture specification. Work ONLY in PHP files (includes/, src/).
    DO NOT touch admin-react/ folder - that's the Frontend Developer's domain.
    
    **IMPORTANT:** Read the skeleton plugin structure at {skeleton_plugin_path} to understand:
    - Existing PHP class naming conventions and patterns
    - Current folder organization (includes/, src/admin/, src/frontend/, src/blocks/)
    - Existing hook registration patterns
    - Database schema patterns (if any)
    - Testing setup and patterns
    
    Follow the skeleton's existing patterns and conventions. If the skeleton uses namespaces,
    use namespaces. If it uses class prefixes, use the same prefixes. Match the coding style.
    
    Implementation requirements:
    1. **PHP Classes** (OOP + SOLID principles)
       - Create classes in includes/ or src/ as per architecture
       - Follow single responsibility principle
       - Use dependency injection
       - Implement interfaces where appropriate
       - Use WordPress coding standards
    
    2. **WordPress Integration**
       - Register hooks and filters properly
       - Implement custom post types/taxonomies
       - Create database tables (if needed)
       - Set up cron jobs (if needed)
    
    3. **REST API Endpoints**
       - Implement REST API routes
       - Add authentication and permission checks
       - Sanitize inputs and validate data
       - Return proper error responses
    
    4. **Security**
       - Use nonces for AJAX/REST requests
       - Sanitize all inputs (sanitize_text_field, wp_kses, etc.)
       - Escape all outputs (esc_html, esc_attr, esc_url)
       - Check user capabilities properly
    
    5. **Testing**
       - Write PHPUnit tests for each class/method
       - Use Brain Monkey for WordPress function mocking
       - Test edge cases and error conditions
       - Aim for high test coverage

  expected_output: >
    Backend implementation saved to outputs/plugin/ maintaining the skeleton structure:
    
    outputs/plugin/
    ├── wp-skeleton-plugin.php        # Updated main plugin file
    ├── includes/                     # Core PHP classes
    │   ├── class-plugin-name.php
    │   ├── class-activator.php
    │   └── ...new classes...
    ├── src/
    │   ├── admin/                    # Admin PHP classes
    │   │   └── ...new admin classes...
    │   ├── frontend/                 # Public PHP classes
    │   │   └── ...new frontend classes...
    │   └── blocks/                   # Gutenberg block PHP
    │       └── ...block registration...
    └── tests/php/                    # PHPUnit tests
        ├── test-class-plugin-name.php
        └── ...corresponding tests...
    
    Include documentation:
    - Inline PHPDoc comments
    - README sections for new features
    - Hook/filter documentation

  agent: wordpress_backend_dev
  context:
    - design_architecture

implement_frontend:
  description: >
    Implement the React admin interface for Milestone {current_milestone} based on
    the architecture specification. Work ONLY in admin-react/ folder.
    DO NOT touch PHP files - that's the Backend Developer's domain.
    
    **IMPORTANT:** Read the skeleton plugin's React structure at {skeleton_plugin_path}/admin-react/ to understand:
    - Existing React version and setup
    - Material-UI version and theme configuration
    - Component naming conventions and patterns
    - Folder organization (components/, pages/, hooks/, utils/)
    - State management approach (Context API, Redux, etc.)
    - API client setup and patterns (how REST API calls are made)
    - Routing setup (React Router configuration)
    - Build configuration (webpack, vite, etc.)
    - Testing patterns (Jest setup, test file naming)
    
    Follow the skeleton's existing React patterns, MUI theme, and component structure.
    Use the same dependencies and coding style as the skeleton.
    
    Implementation requirements:
    1. **React Components** (Material-UI)
       - Create reusable components in src/components/
       - Build page components in src/pages/
       - Follow React best practices (hooks, composition)
       - Use Material-UI components (Button, TextField, Dialog, etc.)
       - Apply MUI theming for consistent design
    
    2. **State Management**
       - Use React Context for global state (if needed)
       - Use custom hooks for data fetching
       - Implement proper loading and error states
    
    3. **API Integration**
       - Connect to WordPress REST API endpoints
       - Handle authentication (nonces, cookies)
       - Implement error handling and retry logic
       - Show user feedback (success/error messages)
    
    4. **Routing**
       - Set up React Router for admin pages
       - Implement navigation between pages
       - Handle deep linking properly
    
    5. **Accessibility & UX**
       - Follow accessibility guidelines (ARIA labels, keyboard nav)
       - Responsive design for all screen sizes
       - Loading states and skeletons
       - Error boundaries for graceful failures
    
    6. **Testing**
       - Write Jest tests for all components
       - Use React Testing Library
       - Test user interactions and edge cases
       - Target 100% code coverage

  expected_output: >
    Frontend implementation saved to outputs/plugin/admin-react/:
    
    outputs/plugin/admin-react/
    ├── src/
    │   ├── components/              # React components
    │   │   ├── ComponentName.jsx
    │   │   └── ComponentName.test.jsx
    │   ├── pages/                   # Page components
    │   │   ├── PageName.jsx
    │   │   └── PageName.test.jsx
    │   ├── hooks/                   # Custom hooks
    │   │   ├── useCustomHook.js
    │   │   └── useCustomHook.test.js
    │   ├── utils/                   # Utilities
    │   │   ├── api.js               # API client
    │   │   └── helpers.js
    │   ├── App.jsx                  # Updated main app
    │   └── index.jsx
    └── package.json                 # Updated dependencies
    
    Include documentation:
    - Component prop documentation (JSDoc)
    - README for setup and development
    - Storybook stories (optional but recommended)

  agent: react_frontend_dev
  context:
    - design_architecture

review_code:
  description: >
    Perform comprehensive code review of both backend (PHP) and frontend (React)
    implementations for Milestone {current_milestone}.
    
    Review backend PHP code (includes/, src/) for:
    1. **Security Vulnerabilities**
       - SQL injection risks (check wpdb usage)
       - XSS vulnerabilities (check escaping)
       - CSRF protection (nonce validation)
       - Capability checks (current_user_can)
       - Input sanitization completeness
    
    2. **SOLID Principles**
       - Single Responsibility violations
       - Open/Closed principle adherence
       - Liskov Substitution correctness
       - Interface Segregation appropriateness
       - Dependency Inversion implementation
    
    3. **WordPress Best Practices**
       - Coding standards compliance (PHPCS)
       - Hook/filter usage correctness
       - Database query optimization
       - Proper use of WordPress functions
       - Internationalization (i18n) implementation
    
    4. **Code Quality**
       - Code duplication (DRY violations)
       - Complex functions (cyclomatic complexity)
       - Missing error handling
       - Inadequate validation
       - Poor naming conventions
    
    Review frontend React code (admin-react/) for:
    1. **React Anti-Patterns**
       - Unnecessary re-renders
       - Missing dependency arrays
       - Prop drilling issues
       - Key prop misuse
       - State management problems
    
    2. **Material-UI Best Practices**
       - Proper theme usage
       - Component composition
       - Responsive design implementation
       - Accessibility compliance
    
    3. **Performance Issues**
       - Unnecessary API calls
       - Missing memoization
       - Large bundle sizes
       - Unoptimized images
    
    4. **Testing Coverage**
       - Missing test cases
       - Untested edge cases
       - Mock implementation issues
       - Assertion completeness

  expected_output: >
    Detailed code review report:
    
    # Code Review Report - {current_milestone}
    
    ## Executive Summary
    - Overall code quality score (1-10)
    - Critical issues count
    - Major issues count
    - Minor issues count
    - Approval status (Approved / Needs Revisions / Rejected)
    
    ## Backend Review (PHP)
    ### Security Issues
    - [CRITICAL/MAJOR/MINOR] Issue description with file:line
    - Recommended fix
    
    ### SOLID Principle Violations
    - Violation description with code examples
    - Refactoring suggestions
    
    ### WordPress Best Practices
    - Issues found with recommendations
    
    ### Code Quality Issues
    - Complexity issues
    - DRY violations
    - Naming problems
    
    ## Frontend Review (React)
    ### React Anti-Patterns
    - Pattern violations with file:line
    - Better alternatives
    
    ### Performance Issues
    - Performance bottlenecks identified
    - Optimization suggestions
    
    ### Accessibility Issues
    - A11y violations
    - ARIA improvements needed
    
    ## Testing Review
    ### Backend Tests (PHPUnit)
    - Coverage analysis
    - Missing test cases
    - Edge cases not covered
    
    ### Frontend Tests (Jest)
    - Coverage analysis
    - Component test completeness
    - Integration test gaps
    
    ## Recommendations
    - Priority 1 (Must Fix): Critical issues
    - Priority 2 (Should Fix): Major issues
    - Priority 3 (Nice to Fix): Minor improvements
    
    ## Edge Cases Identified
    - List of edge cases not handled
    - Suggested handling approaches

  agent: code_reviewer
  context:
    - implement_backend
    - implement_frontend

run_qa_tests:
  description: >
    Perform comprehensive quality assurance testing for Milestone {current_milestone}.
    
    1. **Test Coverage Analysis**
       - Run PHPUnit tests and generate coverage report
       - Run Jest tests and generate coverage report
       - Identify uncovered code paths
       - Verify coverage meets minimum thresholds (80%+ target)
    
    2. **End-to-End Testing** (Playwright)
       Write and execute E2E tests covering:
       - Admin page navigation and workflows
       - Form submissions and validations
       - AJAX/REST API interactions
       - React component interactions
       - Error state handling
       - Loading state behaviors
       - Multi-step workflows
       - User permissions and access control
    
    3. **Integration Testing**
       - Backend REST API → Frontend integration
       - Database operations → API responses
       - WordPress hooks → Plugin behavior
       - Authentication flows
       - Data persistence across page reloads
    
    4. **Cross-Browser Testing**
       - Chrome
       - Firefox
       - Safari
       - Edge
    
    5. **Responsive Design Testing**
       - Desktop (1920x1080)
       - Tablet (768x1024)
       - Mobile (375x667)
    
    6. **Performance Testing**
       - Page load times
       - API response times
       - Bundle size analysis
       - Database query performance
    
    7. **Accessibility Testing**
       - Keyboard navigation
       - Screen reader compatibility
       - Color contrast ratios
       - ARIA label presence

  expected_output: >
    Comprehensive QA report:
    
    # QA Test Report - {current_milestone}
    
    ## Test Summary
    - Total tests executed: X
    - Passed: X
    - Failed: X
    - Skipped: X
    - Overall status: PASS/FAIL
    
    ## Coverage Analysis
    ### Backend (PHPUnit)
    - Line coverage: X%
    - Function coverage: X%
    - Class coverage: X%
    - Uncovered files/functions list
    
    ### Frontend (Jest)
    - Statement coverage: X%
    - Branch coverage: X%
    - Function coverage: X%
    - Line coverage: X%
    - Uncovered components list
    
    ## E2E Test Results (Playwright)
    ### Admin Workflows
    - Test scenario descriptions with PASS/FAIL status
    - Screenshots of failures
    - Error logs
    
    ### API Integration Tests
    - Endpoint test results
    - Response validation results
    
    ### User Journey Tests
    - Multi-step workflow results
    - Edge case scenario results
    
    ## Cross-Browser Results
    - Chrome: PASS/FAIL (issues found)
    - Firefox: PASS/FAIL (issues found)
    - Safari: PASS/FAIL (issues found)
    - Edge: PASS/FAIL (issues found)
    
    ## Responsive Design Results
    - Desktop: PASS/FAIL
    - Tablet: PASS/FAIL
    - Mobile: PASS/FAIL
    
    ## Performance Metrics
    - Average page load time: Xms
    - API response times: Xms
    - Bundle size: XKB
    - Database queries per request: X
    
    ## Accessibility Audit
    - Keyboard navigation: PASS/FAIL
    - Screen reader: PASS/FAIL
    - Color contrast: PASS/FAIL
    - ARIA compliance: PASS/FAIL
    
    ## Issues Found
    ### Critical Issues (Block Release)
    - Issue description with reproduction steps
    
    ### Major Issues (Fix Before Release)
    - Issue description with reproduction steps
    
    ### Minor Issues (Fix if Time Permits)
    - Issue description
    
    ## Test Artifacts
    - Location of test recordings
    - Location of screenshots
    - Location of coverage reports
    
    ## Recommendation
    - APPROVED FOR RELEASE
    - NEEDS FIXES BEFORE RELEASE
    - BLOCKED (critical issues)

  agent: qa_engineer
  context:
    - implement_backend
    - implement_frontend
    - review_code
